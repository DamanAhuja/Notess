# âœ… **UNIT 1 (9 Hours) â€“ Introduction to Software Engineering**

---

## ğŸ”¹ 1. What is Software Engineering?

### âœ… Definition:

**Software Engineering** is the systematic, disciplined, and quantifiable approach to the **development, operation, and maintenance of software**.

> In simple words:
> Software engineering applies **engineering principles** to build **reliable, maintainable, and high-quality software**.

---

### âœ… Why Software Engineering is Needed?

* Software systems are **large and complex**
* Errors are **costly**
* Need:

  * Predictable development
  * Quality assurance
  * Maintainability
  * On-time delivery

---

## ğŸ”¹ 2. Software Engineering â€“ A Layered Approach

Software Engineering is described as a **layered technology**.

### âœ… The Four Layers:

```
--------------------------------
|      Quality Focus           |
--------------------------------
|      Process                 |
--------------------------------
|      Methods                 |
--------------------------------
|      Tools                   |
--------------------------------
```

---

### âœ… 1ï¸âƒ£ Quality Focus (Top Layer)

* Foundation of software engineering
* Emphasizes:

  * Correctness
  * Reliability
  * Maintainability
  * Efficiency

---

### âœ… 2ï¸âƒ£ Process Layer

* Defines **what steps to follow**
* Framework for development

---

### âœ… 3ï¸âƒ£ Methods Layer

* Technical methods used to:

  * Analyze requirements
  * Design system
  * Code
  * Test software

---

### âœ… 4ï¸âƒ£ Tools Layer

* Automated support:

  * IDEs
  * Version control
  * Testing tools
  * Project management tools

---

ğŸ“Œ **Exam Point**:
Quality is the **core**, process is the **glue**, methods are the **how**, tools provide **support**.

---

## ğŸ”¹ 3. Software Process

### âœ… Definition:

A **software process** is a structured set of activities required to develop software.

---

### âœ… Basic Activities of Software Process:

1. Specification
2. Design & Implementation
3. Validation
4. Evolution (Maintenance)

---

## ğŸ”¹ 4. Process Framework

A **Process Framework** provides a **generic structure** for software processes.

---

### âœ… Framework Activities:

1. **Communication**

   * Interaction with customer
   * Requirement gathering

2. **Planning**

   * Estimation
   * Scheduling
   * Resource allocation

3. **Modeling**

   * Analysis & design models

4. **Construction**

   * Coding
   * Testing

5. **Deployment**

   * Delivery
   * Feedback
   * Maintenance

---

## ğŸ”¹ 5. Umbrella Activities

Umbrella activities are applied **throughout the software process**.

---

### âœ… Types of Umbrella Activities:

* Software project tracking & control
* Risk management
* Software quality assurance (SQA)
* Technical reviews
* Configuration management
* Measurement
* Documentation

ğŸ“Œ **Exam Tip**:
Umbrella activities run **parallel** to framework activities.

---

## ğŸ”¹ 6. Software Process Models

A **Process Model** describes:

* The **sequence** of activities
* The **order** of execution

---

# âœ… 6.1 Waterfall Model

---

### âœ… Description:

A **linear sequential model** where each phase must be completed before the next begins.

---

### âœ… Phases:

1. Requirement Analysis
2. System Design
3. Implementation
4. Testing
5. Deployment
6. Maintenance

---

### âœ… Advantages:

* Simple & easy to understand
* Clear documentation
* Suitable for small, stable projects

---

### âŒ Disadvantages:

* No flexibility
* Late testing
* Changes are expensive

---

### ğŸ“Œ Use Case:

* Government projects
* Fixed requirements

---

# âœ… 6.2 Incremental Model

---

### âœ… Description:

Software is developed in **small increments**.
Each increment adds new functionality.

---

### âœ… Characteristics:

* Core product first
* Additional features later
* Each increment follows waterfall steps

---

### âœ… Advantages:

* Early delivery
* Flexible to change
* Lower risk

---

### âŒ Disadvantages:

* Needs good planning
* Integration complexity

---

---

# âœ… 6.3 Evolutionary Process Models

Used when requirements are **not clearly known**.

---

## ğŸ”¹ A. Prototyping Model

---

### âœ… Description:

A **working model (prototype)** is built to understand requirements.

---

### âœ… Steps:

1. Initial requirement gathering
2. Quick design
3. Prototype building
4. User evaluation
5. Refinement

---

### âœ… Advantages:

* Better requirement understanding
* User involvement
* Reduces misunderstandings

---

### âŒ Disadvantages:

* Poor documentation
* Can lead to rushed design

---

---

## ğŸ”¹ B. Spiral Model

---

### âœ… Description:

Combines:

* Iterative development
* Risk analysis

---

### âœ… Each Spiral Loop:

1. Planning
2. Risk analysis
3. Engineering
4. Evaluation

---

### âœ… Advantages:

* Best for large, high-risk projects
* Continuous risk management

---

### âŒ Disadvantages:

* Complex
* Expensive
* Requires expertise

---

---

## ğŸ”¹ 7. Introduction to Agile

---

### âœ… What is Agile?

Agile is a **lightweight, iterative, and flexible approach** to software development.

---

### âœ… Agile Manifesto Values:

* Individuals & interactions > Processes & tools
* Working software > Documentation
* Customer collaboration > Contract negotiation
* Responding to change > Following a plan

---

---

## ğŸ”¹ 8. Agile Model â€“ Scrum

---

### âœ… What is Scrum?

Scrum is the **most popular Agile framework**.

---

### âœ… Scrum Roles:

* Product Owner
* Scrum Master
* Development Team

---

### âœ… Scrum Artifacts:

* Product Backlog
* Sprint Backlog
* Increment

---

### âœ… Scrum Events:

* Sprint (2â€“4 weeks)
* Daily Scrum
* Sprint Review
* Sprint Retrospective

---

### âœ… Advantages of Scrum:

* Fast delivery
* Customer feedback
* Adaptive to changes

---

### âŒ Disadvantages:

* Needs experienced team
* Not suitable for fixed-scope projects

---

# âœ… UNIT 1 â€“ LAST-MINUTE REVISION

* Software Engineering = engineering approach to software
* Layered approach:

  * Quality â†’ Process â†’ Methods â†’ Tools
* Process framework:

  * Communication, Planning, Modeling, Construction, Deployment
* Umbrella activities run throughout
* Models:

  * Waterfall (linear)
  * Incremental (step-by-step)
  * Prototyping (unclear requirements)
  * Spiral (risk-driven)
* Agile:

  * Iterative
  * Flexible
* Scrum:

  * Sprints, roles, backlogs

# âœ… **UNIT 2 â€“ Software Requirements Analysis & Specification**

---

## ğŸ”¹ 1. Software Requirements â€“ Introduction

### âœ… Definition:

A **Software Requirement** is a condition or capability that a system must satisfy to:

* Solve a real-world problem
* Meet user needs
* Fulfill contractual or business objectives

ğŸ“Œ Requirements answer the question:
**â€œWHAT should the system do?â€ (not how)**

---

## ğŸ”¹ 2. Software Requirements Analysis

### âœ… Definition:

**Software Requirements Analysis (SRA)** is the process of:

* Understanding user needs
* Analyzing feasibility
* Documenting requirements clearly and unambiguously

---

### âœ… Objectives of Requirements Analysis:

* Understand the problem domain
* Avoid ambiguity
* Reduce development cost
* Prevent requirement-related failures
* Create a solid foundation for design

---

### âœ… Steps in Requirements Analysis:

1. **Requirement Elicitation**

   * Interviews
   * Questionnaires
   * Observation
   * Workshops

2. **Requirement Analysis**

   * Remove conflicts
   * Prioritize requirements
   * Check feasibility

3. **Requirement Specification**

   * Document requirements formally

4. **Requirement Validation**

   * Ensure correctness & completeness

---

## ğŸ”¹ 3. Types of Software Requirements

---

### âœ… A. Functional Requirements

Define **what the system should do**.

ğŸ“Œ Examples:

* User login
* Money transfer
* Order placement
* Report generation

---

### âœ… B. Non-Functional Requirements

Define **how the system performs**.

ğŸ“Œ Examples:

* Performance
* Security
* Reliability
* Scalability
* Usability

---

### âœ… C. Domain Requirements

* Specific to application domain
* Example:

  * Banking rules
  * Medical regulations

---

## ğŸ”¹ 4. Use Case Approach

---

### âœ… What is a Use Case?

A **Use Case** describes:

* Interaction between **actor (user/system)** and **software**
* To achieve a specific goal

---

### âœ… Components of a Use Case:

| Component       | Description             |
| --------------- | ----------------------- |
| Actor           | User or external system |
| Use Case        | Functionality           |
| System Boundary | Scope of system         |
| Relationships   | Include, Extend         |

---

### âœ… Use Case Diagram (Explained in Words):

* Actor â†’ stick figure
* Use case â†’ oval
* System boundary â†’ rectangle

ğŸ“Œ Example:

* Actor: Customer
* Use cases: Login, Place Order, Make Payment

---

### âœ… Advantages of Use Case Approach:

* Easy to understand
* User-centric
* Helps in test case generation

---

### âŒ Disadvantages:

* Does not show internal logic
* Complex for large systems

---

## ğŸ”¹ 5. Software Requirement Specification (SRS)

---

### âœ… Definition:

An **SRS Document** is a **formal, written description** of all software requirements.

It acts as:

* Contract between customer & developer
* Reference for design, testing & maintenance

---

### âœ… Characteristics of a Good SRS:

* Correct
* Complete
* Unambiguous
* Consistent
* Verifiable
* Modifiable
* Traceable

---

### âœ… Typical Structure of an SRS Document:

1. **Introduction**

   * Purpose
   * Scope
   * Definitions

2. **Overall Description**

   * Product perspective
   * User characteristics
   * Constraints

3. **Specific Requirements**

   * Functional requirements
   * Non-functional requirements
   * Interface requirements

4. **Appendices**

---

### âœ… Importance of SRS:

* Reduces misunderstandings
* Helps cost estimation
* Basis for validation & testing

---

## ğŸ”¹ 6. Flow-Oriented Modeling

---

### âœ… Definition:

Flow-oriented modeling represents:

* How data flows through the system
* How it is processed and transformed

ğŸ“Œ Focus: **Input â†’ Processing â†’ Output**

---

### âœ… Main Elements:

* Data Flow
* Processing
* Data Storage
* External Entities

---

## ğŸ”¹ 7. Data Flow Model (DFD)

---

### âœ… What is a Data Flow Diagram (DFD)?

A **DFD** is a graphical representation showing:

* Flow of data
* Processing steps
* Data storage
* Interaction with external entities

---

### âœ… Symbols Used in DFD:

| Symbol         | Meaning         |
| -------------- | --------------- |
| Circle         | Process         |
| Arrow          | Data flow       |
| Rectangle      | External entity |
| Open rectangle | Data store      |

---

### âœ… Levels of DFD:

---

### ğŸ”¹ Level 0 DFD (Context Diagram)

* Entire system as a **single process**
* Shows interaction with external entities

---

### ğŸ”¹ Level 1 DFD

* Breaks system into sub-processes
* Shows internal data flow

---

### ğŸ”¹ Level 2 DFD

* Further decomposition of Level 1 processes

---

### âœ… Advantages of DFD:

* Easy visualization
* Logical system view
* Helps in requirement clarification

---

### âŒ Disadvantages:

* No control flow
* Complex for large systems

---

## ğŸ”¹ 8. Difference Between Use Case & DFD

| Use Case                     | DFD                     |
| ---------------------------- | ----------------------- |
| User interaction focused     | Data flow focused       |
| Shows system functionality   | Shows data processing   |
| Actor-centric                | Process-centric         |
| Used in requirement analysis | Used in system modeling |

---

## ğŸ”¹ 9. Requirement Validation

---

### âœ… Purpose:

Ensure requirements are:

* Correct
* Complete
* Feasible
* Testable

---

### âœ… Validation Techniques:

* Reviews
* Walkthroughs
* Prototyping
* Test case derivation

---

## ğŸ”¹ 10. Common Requirement Problems

* Ambiguity
* Incompleteness
* Over-specification
* Frequent changes
* Conflicting requirements

---

# âœ… UNIT 2 â€“ LAST-MINUTE REVISION

* Requirements define **what system must do**
* Functional vs Non-Functional requirements
* Use Case:

  * Actor, use case, system boundary
* SRS:

  * Formal requirement document
  * Must be complete & unambiguous
* Flow-oriented model:

  * Data movement & processing
* DFD:

  * Level 0, Level 1, Level 2
* Validation ensures requirement correctness

---

# âœ… **UNIT 3 â€“ Design Modeling**

---

## ğŸ”¹ 1. Introduction to Design Modeling

### âœ… What is Design Modeling?

**Design Modeling** is the process of **transforming the requirements model into a design model** that can be implemented in code.

ğŸ“Œ Requirements answer **WHAT** the system should do
ğŸ“Œ Design answers **HOW** the system will do it

---

### âœ… Objectives of Design Modeling:

* Convert SRS into technical solution
* Provide blueprint for developers
* Reduce development complexity
* Improve maintainability and scalability
* Ensure quality before coding

---

## ğŸ”¹ 2. Translating Requirements Model into Design Model

---

### âœ… Requirement Model Includes:

* Use cases
* Functional requirements
* Non-functional requirements
* Data flow diagrams

---

### âœ… Design Model Includes:

* Architectural design
* Data design
* Interface design
* Component-level design

---

### âœ… Mapping Example:

| Requirement Model | Design Model   |
| ----------------- | -------------- |
| Use case          | Component      |
| DFD process       | Module         |
| Data store        | Database table |
| Actor             | Interface      |

---

ğŸ“Œ **Exam Point:**
Design modeling acts as a **bridge** between analysis and coding.

---

## ğŸ”¹ 3. The Design Process

---

### âœ… Steps in Design Process:

1. **Architectural Design**

   * Overall system structure
   * Subsystems & their relationships

2. **Data Design**

   * Database structures
   * Data objects & relationships

3. **Interface Design**

   * User interfaces
   * APIs
   * External interfaces

4. **Component-Level Design**

   * Detailed logic of each module
   * Algorithms & data structures

---

## ğŸ”¹ 4. Design Concepts (VERY IMPORTANT)

---

# âœ… 4.1 Abstraction

---

### âœ… Definition:

**Abstraction** focuses on **essential features** while hiding unnecessary details.

---

### âœ… Types of Abstraction:

---

#### ğŸ”¹ A. Data Abstraction

* Shows **what data** is used
* Hides **how data is stored**

ğŸ“Œ Example:

* Stack â†’ push(), pop()

---

#### ğŸ”¹ B. Procedural Abstraction

* Shows **what function does**
* Hides **how it is implemented**

ğŸ“Œ Example:

* `calculateSalary()` function

---

### âœ… Advantages of Abstraction:

* Reduces complexity
* Improves understandability
* Easier maintenance

---

## ğŸ”¹ 4.2 Modularity

---

### âœ… Definition:

**Modularity** divides software into **independent modules**.

ğŸ“Œ Each module:

* Performs a specific task
* Has well-defined interfaces

---

### âœ… Advantages of Modularity:

* Easier development
* Parallel work possible
* Easier debugging
* Better maintainability

---

### âŒ Disadvantages of Poor Modularity:

* High dependency
* Hard to maintain
* Ripple effects of changes

---

## ğŸ”¹ 4.3 Functional Independence

---

### âœ… Definition:

A module is **functionally independent** if:

* It performs one task
* Has minimal interaction with other modules

Achieved using:

* **High cohesion**
* **Low coupling**

---

## ğŸ”¹ 5. Cohesion

---

### âœ… Definition:

**Cohesion** measures how closely related the elements inside a module are.

---

### âœ… Types of Cohesion (Low â†’ High):

1. Coincidental
2. Logical
3. Temporal
4. Procedural
5. Communicational
6. Sequential
7. Functional (Best)

---

ğŸ“Œ **Exam Tip:**
Higher cohesion = better design.

---

## ğŸ”¹ 6. Coupling

---

### âœ… Definition:

**Coupling** measures the **degree of dependency between modules**.

---

### âœ… Types of Coupling (High â†’ Low):

1. Content Coupling (Worst)
2. Common Coupling
3. Control Coupling
4. Stamp Coupling
5. Data Coupling (Best)

---

ğŸ“Œ **Exam Tip:**
Lower coupling = better design.

---

## ğŸ”¹ 7. Relationship Between Cohesion & Coupling

| Cohesion | Coupling | Design Quality |
| -------- | -------- | -------------- |
| High     | Low      | Excellent      |
| Low      | High     | Poor           |

---

## ğŸ”¹ 8. Structure Charts

---

### âœ… Definition:

A **Structure Chart** is a hierarchical diagram showing:

* System modules
* Calling relationships
* Data/control flow

---

### âœ… Elements of Structure Chart:

* Module â†’ rectangle
* Call relationship â†’ arrow
* Data couple â†’ arrow with data label
* Control couple â†’ arrow with control flag

---

### âœ… Example Explained in Words:

* Main module at top
* Submodules below
* Each module performs specific task
* Arrows indicate calls

---

### âœ… Advantages of Structure Charts:

* Clear system structure
* Helps in coding
* Improves modularity

---

### âŒ Disadvantages:

* No runtime behavior
* Complex for large systems

---

## ğŸ”¹ 9. Design Quality Attributes

* Correctness
* Efficiency
* Maintainability
* Reusability
* Flexibility
* Robustness

---

## ğŸ”¹ 10. Common Design Problems

* Over-coupling
* Low cohesion
* Poor abstraction
* God modules
* Poor interface design

---

# âœ… UNIT 3 â€“ LAST-MINUTE REVISION

* Design modeling converts **requirements â†’ solution**
* Design process:

  * Architecture
  * Data
  * Interface
  * Component
* Abstraction:

  * Data abstraction
  * Procedural abstraction
* Modularity:

  * Divide & conquer
* Functional independence:

  * High cohesion
  * Low coupling
* Cohesion:

  * Functional is best
* Coupling:

  * Data coupling is best
* Structure charts:

  * Show module hierarchy

# âœ… **UNIT 4 â€“ Software Metrics & Project Estimation**

---

## ğŸ”¹ 1. Introduction to Software Metrics

### âœ… Definition:

A **Software Metric** is a **quantitative measure** that indicates:

* Size
* Complexity
* Quality
* Performance
* Productivity
  of a software product or process.

ğŸ“Œ *â€œYou cannot control what you cannot measure.â€*

---

### âœ… Objectives of Software Metrics:

* Estimate cost & effort
* Measure quality
* Improve productivity
* Monitor project progress
* Support decision-making

---

## ğŸ”¹ 2. Software Measurement

### âœ… Definition:

**Software Measurement** is the process of **assigning numbers to software attributes** according to defined rules.

---

### âœ… Types of Software Metrics:

---

### ğŸ”¹ A. Product Metrics

Measure characteristics of the software product.

* Size
* Complexity
* Performance
* Quality

ğŸ“Œ Example: Lines of Code (LOC)

---

### ğŸ”¹ B. Process Metrics

Measure efficiency of development process.

* Defect removal efficiency
* Development time

---

### ğŸ”¹ C. Project Metrics

Measure project management aspects.

* Effort
* Cost
* Schedule

---

## ğŸ”¹ 3. Function-Based Metrics (VERY IMPORTANT)

---

### âœ… What are Function Points (FP)?

**Function Points** measure software size based on **functionality delivered to the user**, not lines of code.

---

### âœ… Why FP is Better than LOC?

* Language independent
* User-oriented
* Suitable for early estimation

---

### âœ… Components of Function Points:

| Component | Meaning                 |
| --------- | ----------------------- |
| EI        | External Input          |
| EO        | External Output         |
| EQ        | External Inquiry        |
| ILF       | Internal Logical File   |
| EIF       | External Interface File |

---

### âœ… Function Point Calculation Steps:

---

### ğŸ”¹ Step 1: Count Each Component

Each component is classified as:

* Low
* Average
* High

---

### ğŸ”¹ Step 2: Compute Unadjusted Function Points (UFP)

[
UFP = \sum (Count Ã— Weight)
]

---

### ğŸ”¹ Step 3: Compute Value Adjustment Factor (VAF)

Based on **14 General System Characteristics** like:

* Data communications
* Performance
* Security
* Transaction rate

[
VAF = 0.65 + (0.01 Ã— \sum F_i)
]

---

### ğŸ”¹ Step 4: Final Function Point Value

[
FP = UFP Ã— VAF
]

---

ğŸ“Œ **Exam Tip:**
Numericals from FP estimation are **very common**.

---

## ğŸ”¹ 4. Metrics for Software Quality

---

### âœ… Common Software Quality Metrics:

---

### ğŸ”¹ A. Defect Density

[
Defect\ Density = \frac{Number\ of\ Defects}{Size\ of\ Software}
]

---

### ğŸ”¹ B. Mean Time To Failure (MTTF)

Average time between failures.

---

### ğŸ”¹ C. Reliability

Probability of failure-free operation.

---

### ğŸ”¹ D. Maintainability

Ease of fixing and updating software.

---

### ğŸ”¹ E. Availability

[
Availability = \frac{MTTF}{MTTF + MTTR}
]

---

## ğŸ”¹ 5. Software Project Estimation

---

### âœ… What is Project Estimation?

Predicting:

* Effort
* Time
* Cost
* Resources

before development starts.

---

### âœ… Estimation Techniques:

* Expert judgment
* Analogy
* Decomposition
* Algorithmic models

---

## ğŸ”¹ 6. FP-Based Estimation

---

### âœ… Steps:

1. Compute Function Points

2. Determine productivity rate
   (e.g., 10 FP/person-month)

3. Compute effort:
   [
   Effort = \frac{FP}{Productivity}
   ]

4. Compute cost:
   [
   Cost = Effort Ã— Cost\ per\ month
   ]

---

ğŸ“Œ **Example (Exam-style):**
If FP = 200, productivity = 10 FP/PM â†’ Effort = 20 PM

---

## ğŸ”¹ 7. Project Scheduling

---

### âœ… What is Project Scheduling?

Allocating:

* Tasks
* Time
* Resources
  to complete the project efficiently.

---

## ğŸ”¹ 8. Timeline Charts (Gantt Charts)

---

### âœ… Definition:

A **Timeline Chart** shows:

* Project activities
* Duration
* Start & end dates

---

### âœ… Features:

* Easy visualization
* Progress tracking
* Dependency representation

---

### âŒ Limitations:

* Not good for complex dependencies
* No critical path identification

---

## ğŸ”¹ 9. Tracking the Schedule

---

### âœ… Schedule Tracking Methods:

* Milestone tracking
* Earned value analysis
* Regular progress reviews

---

### âœ… Common Schedule Problems:

* Underestimation
* Scope creep
* Resource shortage
* Poor planning

---

## ğŸ”¹ 10. Relationship Between Metrics & Estimation

* Metrics provide **historical data**
* Estimation uses metrics for accuracy
* Better metrics â†’ better estimation

---

# âœ… UNIT 4 â€“ LAST-MINUTE REVISION

* Software metrics = quantitative measures
* Types:

  * Product
  * Process
  * Project
* Function Points:

  * EI, EO, EQ, ILF, EIF
* FP steps:

  * UFP â†’ VAF â†’ FP
* Quality metrics:

  * Defect density
  * Reliability
  * Maintainability
* Estimation:

  * FP based
  * Effort = FP / Productivity
* Scheduling:

  * Timeline charts
  * Schedule tracking

---

# âœ… **UNIT 5 â€“ Quality Control & Risk Management**

---

## ğŸ”¹ 1. Introduction to Software Quality

### âœ… What is Software Quality?

**Software Quality** refers to the degree to which software:

* Meets stated requirements
* Satisfies user needs
* Is reliable, secure, efficient, and maintainable

ğŸ“Œ *Quality is not tested in â€” it is built in.*

---

## ğŸ”¹ 2. Quality Control (QC)

---

### âœ… Definition:

**Quality Control** is the process of **detecting defects** in the software product.

ğŸ‘‰ Focus: **Product-oriented**

---

### âœ… Objectives of QC:

* Identify bugs
* Verify functionality
* Ensure compliance with requirements
* Reduce failure rate

---

### âœ… QC Activities:

* Testing
* Code inspection
* Reviews
* Walkthroughs

---

### âœ… Tools Used in QC:

* Testing tools
* Static code analyzers
* Debuggers

---

## ğŸ”¹ 3. Quality Assurance (QA)

---

### âœ… Definition:

**Quality Assurance** is the process of **preventing defects** by improving processes.

ğŸ‘‰ Focus: **Process-oriented**

---

### âœ… Objectives of QA:

* Improve development process
* Ensure standards are followed
* Prevent future defects

---

### âœ… QA Activities:

* Process definition
* Audits
* Training
* Standards enforcement

---

## ğŸ”¹ 4. Difference Between Quality Control & Quality Assurance (VERY IMPORTANT)

| Quality Control           | Quality Assurance   |
| ------------------------- | ------------------- |
| Product-focused           | Process-focused     |
| Detects defects           | Prevents defects    |
| Reactive                  | Proactive           |
| Testing-oriented          | Process improvement |
| Happens after development | Happens throughout  |

---

## ğŸ”¹ 5. Software Process Assessment & Improvement

---

### âœ… What is Software Process Assessment?

Evaluating the **effectiveness and maturity** of software processes.

---

### âœ… Purpose:

* Identify weaknesses
* Improve productivity
* Reduce defects
* Enhance quality

---

### âœ… Common Process Improvement Models:

---

## ğŸ”¹ A. CMMI (Capability Maturity Model Integration)

### âœ… Maturity Levels:

1. Initial (Chaotic)
2. Managed
3. Defined
4. Quantitatively Managed
5. Optimizing

---

## ğŸ”¹ B. ISO 9001

* International quality standard
* Focuses on:

  * Documentation
  * Process consistency
  * Continuous improvement

---

## ğŸ”¹ C. Six Sigma

* Data-driven quality improvement
* Aim: 3.4 defects per million opportunities

---

## ğŸ”¹ 6. Software Risks

---

### âœ… Definition:

A **Software Risk** is an **uncertain event** that may negatively impact:

* Cost
* Schedule
* Quality
* Performance

---

### âœ… Types of Software Risks:

---

## ğŸ”¹ A. Project Risks

* Schedule delay
* Budget overrun
* Resource shortage

---

## ğŸ”¹ B. Technical Risks

* New technology
* Integration issues
* Performance problems

---

## ğŸ”¹ C. Business Risks

* Market failure
* Legal issues
* Loss of funding

---

## ğŸ”¹ D. External Risks

* Government regulations
* Vendor failures
* Natural disasters

---

## ğŸ”¹ 7. Risk Identification

---

### âœ… Purpose:

Identify potential risks before they occur.

---

### âœ… Risk Identification Techniques:

* Brainstorming
* Checklists
* Past project analysis
* Expert judgment
* SWOT analysis

---

## ğŸ”¹ 8. Risk Projection (Risk Analysis)

---

### âœ… Definition:

Evaluating risks based on:

* Probability of occurrence
* Impact on project

---

### âœ… Risk Exposure Formula:

[
Risk\ Exposure = Probability Ã— Impact
]

---

### âœ… Risk Table Example:

| Risk | Probability | Impact | Exposure |
| ---- | ----------- | ------ | -------- |

---

## ğŸ”¹ 9. Risk Mitigation, Monitoring & Management

---

## âœ… A. Risk Mitigation

Steps taken to **reduce probability or impact**.

ğŸ“Œ Example:

* Training team for new technology

---

## âœ… B. Risk Monitoring

* Continuously tracking identified risks
* Checking warning signs

---

## âœ… C. Risk Management

* Identifying
* Analyzing
* Mitigating
* Monitoring risks throughout project

---

### âœ… Risk Management Strategies:

* Avoid risk
* Reduce risk
* Transfer risk
* Accept risk

---

## ğŸ”¹ 10. Relationship Between Quality & Risk

* Poor quality increases risk
* Early defect detection reduces risk
* Process improvement reduces future risks

---

# âœ… UNIT 5 â€“ LAST-MINUTE REVISION

* Quality = meeting requirements & user expectations
* QC:

  * Detects defects
  * Product-focused
* QA:

  * Prevents defects
  * Process-focused
* Process improvement models:

  * CMMI
  * ISO 9001
  * Six Sigma
* Risk:

  * Uncertain event
* Risk types:

  * Project
  * Technical
  * Business
* Risk management:

  * Identification
  * Projection
  * Mitigation
  * Monitoring

---

# âœ… **UNIT 6 â€“ Software Testing**

---

## ğŸ”¹ 1. Introduction to Software Testing

### âœ… Definition:

**Software Testing** is the process of **executing a program with the intent of finding errors**.

ğŸ“Œ Testing shows the **presence of defects**, not their absence.

---

### âœ… Objectives of Software Testing:

* Detect defects
* Ensure software meets requirements
* Improve quality & reliability
* Reduce cost of failures
* Build user confidence

---

### âœ… Why Testing is Necessary?

* Human errors in coding
* Changing requirements
* Complex software logic
* Security vulnerabilities

---

## ğŸ”¹ 2. Strategic Approach to Software Testing

Testing is done in a **planned and systematic manner**, not randomly.

---

### âœ… Software Testing Strategy Includes:

1. Test planning
2. Test case design
3. Test execution
4. Defect tracking
5. Test reporting

---

### âœ… Testing Strategy Principles:

* Testing starts from **small units** â†’ moves to **complete system**
* Exhaustive testing is impossible
* Early testing saves cost
* Defect clustering exists

---

### âœ… Levels of Testing:

1. Unit Testing
2. Integration Testing
3. Validation Testing
4. System Testing

---

## ğŸ”¹ 3. Unit Testing

---

### âœ… Definition:

**Unit Testing** focuses on testing **individual modules or components**.

---

### âœ… Performed By:

* Developers

---

### âœ… Techniques Used:

* White-box testing
* Statement coverage
* Branch coverage

---

### âœ… Advantages:

* Early defect detection
* Easier debugging
* Reduces integration issues

---

### âŒ Disadvantages:

* Does not detect system-level issues

---

## ğŸ”¹ 4. Integration Testing

---

### âœ… Definition:

**Integration Testing** tests **interaction between integrated modules**.

---

### âœ… Types of Integration Testing:

---

## ğŸ”¹ A. Top-Down Integration Testing

* Testing starts from top-level modules
* Uses **stubs** for lower modules

### âœ… Advantages:

* Early validation of architecture

### âŒ Disadvantages:

* Lower modules tested late

---

## ğŸ”¹ B. Bottom-Up Integration Testing

* Testing starts from lower-level modules
* Uses **drivers** for higher modules

### âœ… Advantages:

* Critical modules tested early

### âŒ Disadvantages:

* No early system prototype

---

## ğŸ”¹ C. Sandwich (Hybrid) Testing

* Combination of top-down & bottom-up

---

## ğŸ”¹ 5. Validation Testing

---

### âœ… Definition:

Validation testing checks:

> **â€œAre we building the right product?â€**

---

### âœ… Focus:

* User requirements
* Functional correctness

---

### âœ… Types of Validation Testing:

* Acceptance testing
* Alpha testing
* Beta testing

---

### ğŸ”¹ A. Alpha Testing

* Conducted at developerâ€™s site
* Controlled environment

---

### ğŸ”¹ B. Beta Testing

* Conducted at customerâ€™s site
* Real-world environment

---

## ğŸ”¹ 6. System Testing

---

### âœ… Definition:

**System Testing** tests the **entire integrated system**.

---

### âœ… Types of System Testing:

* Performance testing
* Security testing
* Stress testing
* Recovery testing
* Usability testing

---

### ğŸ“Œ Example:

* Load testing an e-commerce website during sale

---

## ğŸ”¹ 7. Black-Box Testing

---

### âœ… Definition:

Black-box testing tests software **without knowing internal code**.

ğŸ“Œ Focus: Input â†’ Output behavior

---

### âœ… Techniques of Black-Box Testing:

---

## ğŸ”¹ A. Equivalence Class Partitioning

* Divide input data into valid & invalid classes
* Test one value from each class

---

## ğŸ”¹ B. Boundary Value Analysis

* Tests boundary conditions
* Errors occur at boundaries

ğŸ“Œ Example:

* Range: 1â€“100 â†’ test 0, 1, 100, 101

---

### âœ… Advantages:

* No coding knowledge required
* User-oriented

---

### âŒ Disadvantages:

* Internal logic not tested

---

## ğŸ”¹ 8. White-Box Testing

---

### âœ… Definition:

White-box testing tests **internal logic, code structure, and paths**.

---

### âœ… Performed By:

* Developers

---

### âœ… Techniques of White-Box Testing:

* Statement coverage
* Branch coverage
* Path coverage
* Basis path testing

---

### âœ… Advantages:

* Detects logical errors
* Code coverage ensured

---

### âŒ Disadvantages:

* Time-consuming
* Requires programming knowledge

---

## ğŸ”¹ 9. Basis Path Testing (VERY IMPORTANT â€“ NUMERICAL QUESTIONS)

---

### âœ… Definition:

**Basis Path Testing** is a white-box testing technique that:

* Uses control flow graph (CFG)
* Identifies independent execution paths

---

## ğŸ”¹ Step 1: Draw Control Flow Graph (CFG)

* Nodes â†’ statements
* Edges â†’ control flow

---

## ğŸ”¹ Step 2: Compute Cyclomatic Complexity

---

### âœ… Formula:

[
V(G) = E - N + 2P
]

Where:

* E = Number of edges
* N = Number of nodes
* P = Number of connected components (usually 1)

---

### âœ… Alternative Formula:

[
V(G) = Number\ of\ predicate\ nodes + 1
]

---

### âœ… Meaning:

Cyclomatic complexity gives:

* Number of **independent paths**
* Minimum number of test cases needed

---

## ğŸ”¹ Step 3: Identify Independent Paths

* Each path introduces at least one new edge
* Total paths = Cyclomatic complexity

---

## ğŸ”¹ 10. Difference Between Black-Box & White-Box Testing (VERY IMPORTANT)

| Black-Box           | White-Box               |
| ------------------- | ----------------------- |
| No code knowledge   | Code knowledge required |
| Tests functionality | Tests logic & structure |
| User-oriented       | Developer-oriented      |
| Examples: BVA, ECP  | Examples: Basis path    |

---

## ğŸ”¹ 11. Testing vs Debugging

| Testing              | Debugging               |
| -------------------- | ----------------------- |
| Finds defects        | Fixes defects           |
| Performed by testers | Performed by developers |
| Preventive           | Corrective              |

---

## ğŸ”¹ 12. Common Myths of Software Testing

* Testing removes all bugs âŒ
* Testing is only testerâ€™s job âŒ
* Testing starts after coding âŒ

---

# âœ… UNIT 6 â€“ LAST-MINUTE REVISION (VERY IMPORTANT)

* Testing = finding defects
* Testing levels:

  * Unit
  * Integration
  * Validation
  * System
* Integration testing:

  * Top-down (stubs)
  * Bottom-up (drivers)
* Black-box testing:

  * Equivalence partitioning
  * Boundary value analysis
* White-box testing:

  * Basis path testing
* Cyclomatic complexity:

  * V(G) = E âˆ’ N + 2P
* Independent paths = Cyclomatic complexity

---
